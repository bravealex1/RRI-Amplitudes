# -*- coding: utf-8 -*-
"""RRI&Amplitudes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JeGIuYtQS2Iwclv4r5NFn6FHF2cf5Nax
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.
import kagglehub
bettycxh06_apnea_ecg_database_path = kagglehub.dataset_download('bettycxh06/apnea-ecg-database')

print('Data source import complete.')

!pip install neurokit2
!pip install wfdb

# import os
# import numpy as np
# import pandas as pd
# import neurokit2 as nk
# import wfdb
# from sklearn.model_selection import train_test_split
# from sklearn.ensemble import RandomForestClassifier
# from sklearn.metrics import classification_report, accuracy_score

# # Define the path to the dataset
# data_path = '/root/.cache/kagglehub/datasets/bettycxh06/apnea-ecg-database/versions/7'  # Update this to the actual dataset path

# # List of ECG record names to process
# record_names = ['a01', 'a02', 'a03']  # Add more records as needed

# # Initialize lists to store features and labels
# all_features = []
# all_labels = []

# # Process each ECG record
# for record_name in record_names:
#     try:
#         # Load the ECG signal and annotations
#         record_path = os.path.join(data_path, record_name)
#         record = wfdb.rdrecord(record_path)
#         ecg_signal = record.p_signal[:, 0]  # Assuming ECG is in the first channel
#         annotation = wfdb.rdann(record_path, 'apn')
#         labels = annotation.symbol  # Apnea (A) or Normal (N)

#         # Clean the ECG signal
#         ecg_cleaned = nk.ecg_clean(ecg_signal, sampling_rate=record.fs)

#         # Detect R-peaks
#         r_peaks, _ = nk.ecg_peaks(ecg_cleaned, sampling_rate=record.fs)

#         # Extract features
#         rr_intervals = np.diff(r_peaks['ECG_R_Peaks']) / record.fs * 1000  # R-R intervals in ms
#         r_amplitudes = ecg_cleaned[r_peaks['ECG_R_Peaks']]

#         # Aggregate features for each segment
#         for i in range(len(labels)):
#             if i < len(rr_intervals) and labels[i] in ['A', 'N']:
#                 all_features.append([np.mean(rr_intervals), np.std(rr_intervals), np.mean(r_amplitudes)])
#                 all_labels.append(1 if labels[i] == 'A' else 0)  # 1: Apnea, 0: Normal

#     except Exception as e:
#         print(f"Error processing record {record_name}: {e}")

# # Convert features and labels to arrays
# all_features = np.array(all_features)
# all_labels = np.array(all_labels)

# # Split the data
# X_train, X_test, y_train, y_test = train_test_split(all_features, all_labels, test_size=0.3, random_state=42)

# print(f"Training samples: {len(y_train)}, Testing samples: {len(y_test)}")

# # Train a Random Forest Classifier
# clf = RandomForestClassifier(n_estimators=100, random_state=42)
# clf.fit(X_train, y_train)

# # Predict on the test set
# y_pred = clf.predict(X_test)

# # Evaluate the model
# print("Classification Report:")
# print(classification_report(y_test, y_pred))

# accuracy = accuracy_score(y_test, y_pred)
# print(f"Accuracy: {accuracy * 100:.2f}%")

import os
import numpy as np
import pandas as pd
import neurokit2 as nk
import wfdb
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score

# Define the path to the dataset
base_path = '/root/.cache/kagglehub/datasets/bettycxh06/apnea-ecg-database/versions/7/apnea-ecg-database-1.0.0'
data_path = os.path.join(base_path, 'apnea-ecg-database-1.0.0')

# List of ECG record names to process
record_names = ["a01", "a02", "a03", "a04", "a05", "a06", "a07", "a08", "a09", "a10",
        "a11", "a12", "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20",
        "b01", "b02", "b03", "b04", "b05",
        "c01", "c02", "c03", "c04", "c05", "c06", "c07", "c08", "c09", "c10"]

# Initialize lists to store features and labels
all_features = []
all_labels = []

# Process each ECG record
for record_name in record_names:
    try:
        # Load the ECG signal and annotations
        record_path = os.path.join(data_path, record_name)

        # Print statement to check if the record is being loaded
        print(f"Loading record: {record_name}")

        record = wfdb.rdrecord(record_path)
        ecg_signal = record.p_signal[:, 0]  # Assuming ECG is in the first channel
        annotation = wfdb.rdann(record_path, 'apn')
        labels = annotation.symbol  # Apnea (A) or Normal (N)

        # Print statement to check if annotations are loaded correctly
        print(f"Loaded annotations: {labels}")

        # Clean the ECG signal
        ecg_cleaned = nk.ecg_clean(ecg_signal, sampling_rate=record.fs)

        # Detect R-peaks
        r_peaks, _ = nk.ecg_peaks(ecg_cleaned, sampling_rate=record.fs)

        # Check if R-peaks were detected, need at least 2 for RR intervals
        if len(r_peaks['ECG_R_Peaks']) < 2:
            print(f"Warning: Insufficient R-peaks detected in {record_name}. Skipping.")
            continue

        # Extract features
        rr_intervals = np.diff(r_peaks['ECG_R_Peaks']) / record.fs * 1000  # R-R intervals in ms
        r_amplitudes = ecg_cleaned[r_peaks['ECG_R_Peaks']]

        # Aggregate features for each segment, include all segments with a label
        # Ensure that the loop iterates over the minimum length to avoid index errors
        for i in range(min(len(labels), len(rr_intervals), len(r_amplitudes) - 1)):
            if labels[i] in ['A', 'N']:
                # Calculate features using available data points up to current index
                rr_mean = np.mean(rr_intervals[:i + 1])
                rr_std = np.std(rr_intervals[:i + 1])
                r_amp_mean = np.mean(r_amplitudes[:i + 1])

                all_features.append([rr_mean, rr_std, r_amp_mean])
                all_labels.append(1 if labels[i] == 'A' else 0)  # 1: Apnea, 0: Normal

        # Print to indicate successful processing of record
        print(f"Processed record: {record_name}")

    except Exception as e:
        print(f"Error processing record {record_name}: {e}")

# Convert features and labels to arrays
all_features = np.array(all_features)
all_labels = np.array(all_labels)

# Split the data
X_train, X_test, y_train, y_test = train_test_split(all_features, all_labels, test_size=0.3, random_state=42)

print(f"Training samples: {len(y_train)}, Testing samples: {len(y_test)}")

# Train a Random Forest Classifier
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)

# Evaluate the model
y_pred = clf.predict(X_test)
print("Classification Report:")
print(classification_report(y_test, y_pred))
print(f"Accuracy: {accuracy_score(y_test, y_pred)}")

import os
import numpy as np
import neurokit2 as nk
import wfdb
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score

# Define the path to the dataset
base_path = '/root/.cache/kagglehub/datasets/bettycxh06/apnea-ecg-database/versions/7/apnea-ecg-database-1.0.0'
data_path = os.path.join(base_path, 'apnea-ecg-database-1.0.0')

# List of ECG record names to process
record_names = [
    "a01", "a02", "a03", "a04", "a05", "a06", "a07", "a08", "a09", "a10",
    "a11", "a12", "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20",
    "b01", "b02", "b03", "b04", "b05",
    "c01", "c02", "c03", "c04", "c05", "c06", "c07", "c08", "c09", "c10"
]

# Initialize lists to store features and labels
all_features = []
all_labels = []

# Process each ECG record
for record_name in record_names:
    try:
        # Construct the full path to the record
        record_path = os.path.join(data_path, record_name)
        print(f"Loading record: {record_name}")

        # Load the ECG signal
        record = wfdb.rdrecord(record_path)
        ecg_signal = record.p_signal[:, 0]  # Assuming ECG is in the first channel

        # Load the annotations
        annotation = wfdb.rdann(record_path, 'apn')
        labels = annotation.symbol  # 'A' for Apnea, 'N' for Normal
        print(f"Loaded annotations: {labels}")

        # Clean the ECG signal
        ecg_cleaned = nk.ecg_clean(ecg_signal, sampling_rate=record.fs)

        # Detect R-peaks
        r_peaks = nk.ecg_findpeaks(ecg_cleaned, sampling_rate=record.fs)['ECG_R_Peaks']

        # Check if sufficient R-peaks are detected
        if len(r_peaks) < 2:
            print(f"Warning: Insufficient R-peaks detected in {record_name}. Skipping.")
            continue

        # Extract RR intervals (time between R-peaks) in milliseconds
        rr_intervals = np.diff(r_peaks) / record.fs * 1000

        # Extract R-peak amplitudes
        r_amplitudes = ecg_cleaned[r_peaks]

        # Aggregate features for each segment
        for i in range(min(len(labels), len(rr_intervals))):
            if labels[i] in ['A', 'N']:
                # Calculate mean and standard deviation of RR intervals up to the current index
                rr_mean = np.mean(rr_intervals[:i + 1])
                rr_std = np.std(rr_intervals[:i + 1])
                # Calculate mean amplitude of R-peaks up to the current index
                r_amp_mean = np.mean(r_amplitudes[:i + 1])

                # Append features and corresponding label
                all_features.append([rr_mean, rr_std, r_amp_mean])
                all_labels.append(1 if labels[i] == 'A' else 0)  # 1: Apnea, 0: Normal

        print(f"Processed record: {record_name}")

    except Exception as e:
        print(f"Error processing record {record_name}: {e}")

# Convert features and labels to numpy arrays
all_features = np.array(all_features)
all_labels = np.array(all_labels)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(all_features, all_labels, test_size=0.3, random_state=42)

print(f"Training samples: {len(y_train)}, Testing samples: {len(y_test)}")

# Initialize and train a Random Forest Classifier
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)

# Predict on the test set
y_pred = clf.predict(X_test)

# Evaluate the model
print("Classification Report:")
print(classification_report(y_test, y_pred))
accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy * 100:.2f}%")

!pip install lazypredict

import os
import numpy as np
import neurokit2 as nk
import wfdb
from sklearn.model_selection import train_test_split
from lazypredict.Supervised import LazyClassifier

# Define the path to the dataset
base_path = '/root/.cache/kagglehub/datasets/bettycxh06/apnea-ecg-database/versions/7/apnea-ecg-database-1.0.0'
data_path = os.path.join(base_path, 'apnea-ecg-database-1.0.0')

# List of ECG record names to process
record_names = ["a01", "a02", "a03", "a04", "a05", "a06", "a07", "a08", "a09", "a10",
    "a11", "a12", "a13", "a14", "a15", "a16", "a17", "a18", "a19", "a20",
    "b01", "b02", "b03", "b04", "b05",
    "c01", "c02", "c03", "c04", "c05", "c06", "c07", "c08", "c09", "c10"]  # Add more records as needed

# Initialize lists to store features and labels
all_features = []
all_labels = []

# Process each ECG record
for record_name in record_names:
    try:
        # Load the ECG signal and annotations
        record_path = os.path.join(data_path, record_name)
        record = wfdb.rdrecord(record_path)
        ecg_signal = record.p_signal[:, 0]  # Assuming ECG is in the first channel
        annotation = wfdb.rdann(record_path, 'apn')
        labels = annotation.symbol  # Apnea (A) or Normal (N)

        # Clean the ECG signal
        ecg_cleaned = nk.ecg_clean(ecg_signal, sampling_rate=record.fs)

        # Detect R-peaks
        r_peaks = nk.ecg_findpeaks(ecg_cleaned, sampling_rate=record.fs)['ECG_R_Peaks']

        # Check if sufficient R-peaks are detected
        if len(r_peaks) < 2:
            print(f"Warning: Insufficient R-peaks detected in {record_name}. Skipping.")
            continue

        # Extract RR intervals (time between R-peaks) in milliseconds
        rr_intervals = np.diff(r_peaks) / record.fs * 1000

        # Extract R-peak amplitudes
        r_amplitudes = ecg_cleaned[r_peaks]

        # Aggregate features for each segment
        for i in range(min(len(labels), len(rr_intervals))):
            if labels[i] in ['A', 'N']:
                # Calculate mean and standard deviation of RR intervals up to the current index
                rr_mean = np.mean(rr_intervals[:i + 1])
                rr_std = np.std(rr_intervals[:i + 1])
                # Calculate mean amplitude of R-peaks up to the current index
                r_amp_mean = np.mean(r_amplitudes[:i + 1])

                # Append features and corresponding label
                all_features.append([rr_mean, rr_std, r_amp_mean])
                all_labels.append(1 if labels[i] == 'A' else 0)  # 1: Apnea, 0: Normal

        print(f"Processed record: {record_name}")

    except Exception as e:
        print(f"Error processing record {record_name}: {e}")

# Convert features and labels to numpy arrays
all_features = np.array(all_features)
all_labels = np.array(all_labels)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(all_features, all_labels, test_size=0.3, random_state=42)

# Initialize and fit LazyClassifier
clf = LazyClassifier(verbose=0, ignore_warnings=True, custom_metric=None)
models, predictions = clf.fit(X_train, X_test, y_train, y_test)

# Display model performance
print(models)

